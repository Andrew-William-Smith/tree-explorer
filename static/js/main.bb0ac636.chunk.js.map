{"version":3,"sources":["components/HighlightNode/HighlightNode.tsx","stores/ApplicationStore.ts","stores/AbstractTree.tsx","stores/NaiveTree.tsx","components/HighlightNode/NodeColour.tsx","stores/RedBlackTree.tsx","components/Sidebar/TreeItem/TreeItem.tsx","components/Sidebar/Sidebar.tsx","components/TreeDisplay/TreeNode/TreeNode.tsx","components/ExplanationPane/ExplanationPane.tsx","components/TreeDisplay/TreeDisplay.tsx","components/App.tsx","components/CollapsiblePane/CollapsiblePane.tsx","components/ErrorBoundary/ErrorBoundary.tsx","index.tsx"],"names":["HighlightColours","Traversal","HighlightNode","inject","observer","props","node","renderProps","highlightColour","colour","applicationStore","tree","highlightedNodes","push","style","color","this","fontWeight","children","React","Component","BinaryTreeNode","value","parent","leftChild","rightChild","topAnchor","x","y","bottomAnchor","curNode","grandparent","sibling","observable","AbstractTree","action","bound","explain","items","root","explainFunction","size","numOperations","forEach","item","addItem","title","message","terminal","directionName","explainStep","GREEN","BLUE","newNode","final","addRecursive","newValue","explainNavigation","navigatePreOrder","continuePreOrder","explainTraverseCurrent","explainTraverseLeft","explainTraverseRight","navigateInOrder","continueInOrder","navigatePostOrder","continuePostOrder","prefix","callback","NaiveTree","addNodeNaive","removeRecursive","isLeaf","RED","minChild","newRightChild","NodeColour","RedBlackTree","BLACK","addedNode","rebalance","ommer","ORANGE","rebalanceDifferingAntecedents","doRotateLeft","isRightChild","isLeftChild","doRotateRight","rotateDirection","rotateLeft","rotateRight","oldRight","oldParent","oldLeft","findRemovedNode","removedNode","spliceNode","definedChild","removeLeaf","nodeDescription","rebalanceRootDoubleBlack","rebalanceRotateRedSibling","rebalanceBlackCluster","rebalanceAlternatingSiblingBranch","rebalanceRotateRedInnerNibling","inner","outer","rebalanceRotateRedOuterNibling","leaf","makeNull","ApplicationStore","explanationPromise","toaster","showToast","intent","icon","show","explanation","a","explanationTitle","explanationBody","explanationTerminal","explaining","Promise","resolve","reject","setTimeout","animationInterval","treeOperating","explainAdd","explainRemove","explainTraverse","Toaster","create","Position","BOTTOM_RIGHT","includes","Intent","WARNING","IconNames","WARNING_SIGN","index","removeItem","then","splice","reset","newTabId","prevTabId","oldItems","traversal","traversalGenerator","PRE_ORDER","IN_ORDER","POST_ORDER","traversePreOrder","traverseInOrder","traversePostOrder","val","TreeItem","removeNode","removeItemAtIndex","className","DANGER","onClick","disabled","Sidebar","addTreeItemKbd","evt","key","addTreeItem","state","addOneValue","setState","addManyAscending","addManyValue","i","addManyDescending","addManyRandom","itemNum","newIdx","Math","floor","random","setAnimationInterval","interval","store","treeItemList","map","idx","treeItems","length","fill","onValueChange","asNum","asString","leftIcon","NEW_OBJECT","placeholder","onKeyUp","SUCCESS","ADD_TO_ARTIFACT","content","position","BOTTOM","SORT_NUMERICAL","SORT_NUMERICAL_DESC","SOCIAL_MEDIA","checked","label","onChange","toggleExplainAdd","inline","toggleExplainRemove","toggleExplainTraverse","min","max","stepSize","labelStepSize","traverse","clearTree","TreeNode","ownRef","setRenderProps","bounds","current","getBoundingClientRect","xCoordinate","offsetLeft","width","offsetTop","height","createRef","borderColor","backgroundColor","leftNode","highlight","rightNode","ref","DISABLE","nextProps","prevState","nodeColour","highlighted","ExplanationPane","continueRef","nextStep","continueAnimation","actionButtons","rightIcon","FAST_FORWARD","text","STEP_FORWARD","PRIMARY","TICK","display","TreeDisplay","renderedConnections","renderConnections","newConnectionLines","renderNodeConnections","connectionLines","lines","createConnection","child","parentAnchor","childAnchor","leftPos","xDiff","yDiff","sqrt","pow","angle","atan","left","top","transform","treeRoot","App","align","Alignment","LEFT","animate","large","changeTreeType","id","RIGHT","href","target","rel","CollapsiblePane","togglePaneOpen","isOpen","collapseClass","CHEVRON_DOWN","titleActionsLeft","titleActionsRight","ErrorBoundary","error","PULSE","name","stack","APPLICATION_STORE","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bb0ac636.chunk.js","sourcesContent":["import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport ApplicationStore from '../../stores/ApplicationStore';\nimport { BinaryTreeNode } from '../../stores/AbstractTree';\n\n/** Colours for highlighting nodes.  Derived from Blueprint swatches. */\nexport enum HighlightColours {\n    GREEN = '#0D8050',\n    BLUE = '#106BA3',\n    ORANGE = '#BF7326',\n    RED = '#C23030'\n}\n\ninterface IHighlightNodeProps {\n    children: React.ReactNode;\n    applicationStore?: ApplicationStore;\n    node: BinaryTreeNode;\n    colour: HighlightColours;\n}\n\n@inject('applicationStore')\n@observer\nexport default class HighlightNode extends React.Component<IHighlightNodeProps, {}> {\n    constructor(props: IHighlightNodeProps) {\n        super(props);\n        this.props.node.renderProps.highlightColour = this.props.colour;\n        this.props.applicationStore!.tree.highlightedNodes.push(this.props.node);\n    }\n\n    render(): React.ReactNode {\n        return <span style={{color: this.props.colour, fontWeight: 600}}>&#32;{this.props.children}</span>\n    }\n}\n","import { action, observable } from 'mobx';\nimport { Intent, IToaster, Position, TabId, Toaster } from '@blueprintjs/core';\nimport { IconNames, IconName } from '@blueprintjs/icons';\n\nimport { AbstractTree } from './AbstractTree';\nimport NaiveTree from './NaiveTree';\nimport RedBlackTree from './RedBlackTree';\n\n/** Types of tree traversals that may be performed. */\nexport enum Traversal {\n    PRE_ORDER, IN_ORDER, POST_ORDER\n}\n\nexport interface IApplicationStore {\n    /** Array of all items stored in the current application state. */\n    items: Array<number>;\n    /** Tree currently being displayed and modified. */\n    tree: AbstractTree;\n    /** Whether a tree operation is currently being performed. */\n    treeOperating: boolean;\n\n    /** Whether to explain additions to the tree. */\n    explainAdd: boolean;\n    /** Whether to explain deletions from the tree. */\n    explainRemove: boolean;\n    /** Whether to explain traversals of the tree. */\n    explainTraverse: boolean;\n    /** Whether an explanation is ongoing. */\n    explaining: boolean;\n    /** Promise values for the current explanation step. */\n    explanationPromise: { resolve: any, reject: any } | null;\n    /** Title of the ongoing explanation. */\n    explanationTitle: string;\n    /** Body of the ongoing explanation. */\n    explanationBody: React.ReactElement | null;\n    /** Whether the current step is the final step of the explanation. */\n    explanationTerminal: boolean;\n    /** The time in milliseconds for which to pause between animation frames. */\n    animationInterval: number;\n}\n\nexport default class ApplicationStore implements IApplicationStore {\n    @observable items: Array<number>;\n    @observable tree: AbstractTree;\n    @observable treeOperating: boolean;\n\n    @observable explainAdd: boolean;\n    @observable explainRemove: boolean;\n    @observable explainTraverse: boolean;\n    @observable explaining: boolean;\n    explanationPromise: { resolve: any, reject: any } | null;\n    @observable explanationTitle: string;\n    @observable explanationBody: React.ReactElement | null;\n    @observable explanationTerminal: boolean;\n    @observable animationInterval: number;\n\n    /** Used to display toast notifications within this application. */\n    private toaster: IToaster;\n\n    constructor() {\n        this.items = [];\n        this.tree = new NaiveTree(this.explainStep);\n        this.treeOperating = false;\n\n        // Initialise explanation parameters\n        this.explainAdd = true;\n        this.explainRemove = true;\n        this.explainTraverse = true;\n        this.explaining = false;\n        this.explanationPromise = null;\n        this.explanationTitle = '';\n        this.explanationBody = null;\n        this.explanationTerminal = false;\n        this.animationInterval = 150;\n\n        // Show toast notifications in the top right corner\n        this.toaster = Toaster.create({\n            'position': Position.BOTTOM_RIGHT\n        });\n    }\n\n    /**\n     * Add the specified item to all trees in the current workspace.  If the\n     * item already exists in the trees, show a toast notification and do not\n     * add.\n     * \n     * @param item The item to which to add to the trees.\n     */\n    @action.bound\n    public addItem = async (item: number) => {\n        if (this.items.includes(item)) {\n            this.showToast(`Cannot add duplicate item \"${item}\" to tree.`,\n                Intent.WARNING, IconNames.WARNING_SIGN);\n        } else {\n            this.treeOperating = true;\n            this.explaining = this.explainAdd;\n            await this.tree.addItem(item);\n            this.items.push(item)\n            this.treeOperating = false;\n        }\n    };\n\n    /**\n     * Remove the item at the specified index in the list of items from all\n     * trees in the current workspace.\n     * \n     * @param index The index whose item to remove.\n     */\n    @action.bound\n    public removeItemAtIndex = (index: number) => {\n        this.treeOperating = true;\n        this.explaining = this.explainRemove;\n        this.tree.removeItem(this.items[index]).then(() => {\n            this.items.splice(index, 1);\n            this.treeOperating = false;\n        });\n    }\n\n    /**\n     * Remove all items from the current tree.\n     */\n    @action.bound\n    public clearTree = () => {\n        this.items = [];\n        this.tree.reset();\n    }\n\n    /**\n     * Reset the tree to the specified type, retaining elements in the order in\n     * which they were added.  Event handler for blueprint/Tabs onChange.\n     */\n    @action.bound\n    public changeTreeType = async (newTabId: TabId, prevTabId: TabId) => {\n        // If the tab did not actually change, ignore it\n        if (newTabId === prevTabId) {\n            return;\n        }\n\n        // Set tree type based on selected tab\n        if (newTabId === 'naiveTree') {\n            this.tree = new NaiveTree(this.explainStep);\n        } else if (newTabId === 'redBlackTree') {\n            this.tree = new RedBlackTree(this.explainStep);\n        }\n\n        // Re-add items in the order in which they were added\n        let oldItems = [...this.items];\n        this.items = [];\n        for (const item of oldItems) {\n            await this.addItem(item);\n        }\n    }\n\n    /**\n     * Perform a full traversal of the current tree.\n     */\n    @action.bound\n    public traverse = async (traversal: Traversal) => {\n        this.treeOperating = true;\n        this.explaining = this.explainTraverse;\n\n        // Create generator for requested traversal\n        let traversalGenerator = null;\n        switch (traversal) {\n            case Traversal.PRE_ORDER:\n                traversalGenerator = this.tree.traversePreOrder();\n                break;\n            case Traversal.IN_ORDER:\n                traversalGenerator = this.tree.traverseInOrder();\n                break;\n            case Traversal.POST_ORDER:\n                traversalGenerator = this.tree.traversePostOrder();\n        }\n\n        // Clear items and relist from traversal generator\n        this.items = [];\n        for await (const val of traversalGenerator) {\n            this.items.push(val);\n        }\n        this.treeOperating = false;\n    }\n\n    /**\n     * Toggle whether item additions should be explained in detail.\n     */\n    @action.bound\n    public toggleExplainAdd = () => {\n        this.explainAdd = !this.explainAdd;\n    }\n\n    /**\n     * Toggle whether item removals should be explained in detail.\n     */\n    @action.bound\n    public toggleExplainRemove = () => {\n        this.explainRemove = !this.explainRemove;\n    }\n\n    /**\n     * Toggle whether tree traversals should be explained in detail.\n     */\n    @action.bound\n    public toggleExplainTraverse = () => {\n        this.explainTraverse = !this.explainTraverse;\n    }\n\n    /**\n     * Show a toast message containing the specified message, coloured\n     * according to the specified intent and decorated with the specified icon.\n     */\n    public showToast = (message: string, intent: Intent, icon: IconName) => {\n        this.toaster.show({\n            'message': message,\n            'intent': intent,\n            'icon': icon\n        });\n    }\n\n    /**\n     * Show an explanation for a single step of an operation.  If there is no\n     * current explanation occurring, pause for a bit to allow animation.\n     * \n     * @param title The title of this step.\n     * @param explanation A React element explaining what is happening in this\n     *     step.\n     * @param terminal Whether this is the final step of the operation.\n     */\n    public explainStep = async (title: string, explanation: React.ReactElement, terminal: boolean = false) => {\n        this.explanationTitle = title;\n        this.explanationBody = explanation;\n        this.explanationTerminal = terminal;\n\n        if (this.explaining) {\n            // If explaining, create a user-controllable promise\n            return new Promise((resolve, reject) => {\n                this.explanationPromise = { resolve, reject };\n            });\n        } else {\n            // Otherwise, create a timeout-based promise\n            return new Promise((resolve, reject) => {\n                setTimeout(resolve, this.animationInterval);\n            });\n        }\n    }\n}\n","import React from 'react';\nimport { action, observable } from 'mobx';\nimport HighlightNode, { HighlightColours } from '../components/HighlightNode/HighlightNode';\n\ntype ExplainPromise = (title: string, message: React.ReactElement, terminal?: boolean) => Promise<any>;\n\n/** Properties of binary tree nodes used exclusively for rendering. */\ninterface IBinaryTreeNodeRender {\n    /** The position of the center-top anchor of this node. */\n    topAnchor: { x: number, y: number };\n    /** The position of the center-bottom anchor of this node. */\n    bottomAnchor: { x: number, y: number };\n    /** The colour with which to highlight this node. */\n    highlightColour: string | null;\n}\n\n/**\n * A single node within a binary search tree.  Stores a colour to aid in\n * implementing self-balancing trees.\n */\nexport class BinaryTreeNode {\n    /** The value stored in this tree node. */\n    value: number | null;\n    /** The colour of this node. */\n    @observable colour: string;\n    /** The parent of this node. */\n    parent: BinaryTreeNode | null;\n    /** The subordinate node stored to the left of this node. */\n    leftChild: BinaryTreeNode | null;\n    /** The subordinate node stored to the right of this node. */\n    rightChild: BinaryTreeNode | null;\n    /** Rendering properties for this node. */\n    @observable renderProps: IBinaryTreeNodeRender;\n\n    constructor(value: number | null, colour: string = 'black') {\n        this.value = value;\n        this.colour = colour;\n        this.parent = null;\n\n        // If the value is non-null, create children\n        if (this.value !== null) {\n            this.leftChild = new BinaryTreeNode(null);\n            this.rightChild = new BinaryTreeNode(null);\n        } else {\n            this.leftChild = null;\n            this.rightChild = null;\n        }\n\n        // Set initial rendering properties for this node\n        this.renderProps = {\n            topAnchor: { x: 0, y: 0 },\n            bottomAnchor: { x: 0, y: 0 },\n            highlightColour: null\n        };\n    }\n\n    /**\n     * The grandparent (parent of parent) of this node.\n     */\n    public get grandparent(): BinaryTreeNode | null {\n        // If there is no parent, there cannot be a grandparent\n        if (this.parent === null)\n            return null;\n\n        return this.parent.parent;\n    }\n\n    /**\n     * The sibling of this node: the other node with the same parent as this\n     * node, provided this node has a parent.\n     */\n    public get sibling(): BinaryTreeNode | null {\n        // If there is no parent, there cannot be a sibling\n        if (this.parent === null)\n            return null;\n\n        if (this.parent.leftChild === this)\n            return this.parent.rightChild;\n        return this.parent.leftChild;\n    }\n\n    /**\n     * The ommer (aunt/uncle) of this node: the other node with the same\n     * grandparent as this node's parent.\n     */\n    public get ommer(): BinaryTreeNode | null {\n        // If there is no grandparent, there cannot be an ommer\n        if (this.grandparent === null)\n            return null;\n\n        return this.parent!.sibling;\n    }\n\n    /** Determine whether this tree node represents a leaf. */\n    public isLeaf(): boolean {\n        return this.leftChild !== null && this.leftChild.value === null\n            && this.rightChild !== null && this.rightChild.value === null;\n    }\n\n    /** Determine the value of the smallest child of this node. */\n    public minChild(): BinaryTreeNode {\n        let curNode: BinaryTreeNode = this;\n        // Navigate as far left as possible\n        while (curNode.leftChild !== null && curNode.leftChild.value !== null)\n            curNode = curNode.leftChild;\n        // Once we reach a dead end, we have found the minimum\n        return curNode;\n    }\n\n    /** Make this node into a null terminator. */\n    public makeNull(): void {\n        this.value = null;\n        this.colour = 'black';\n        this.leftChild = null;\n        this.rightChild = null;\n    }\n\n    /** Returns whether this node is the left child of its parent. */\n    public isLeftChild(): boolean {\n        return this.parent !== null && this === this.parent.leftChild;\n    }\n\n    /** Returns whether this node is the right child of its parent. */\n    public isRightChild(): boolean {\n        return this.parent !== null && this === this.parent.rightChild;\n    }\n}\n\n/**\n * Some variant of a binary search tree.  Controls tree display, explanation,\n * and any additional properties that must be displayed for the tree.\n */\nexport abstract class AbstractTree {\n    /** The root of this tree. */\n    root: BinaryTreeNode;\n    /** The size of this tree, used to determine when to rerender. */\n    @observable size: number;\n    /** The number of operations performed on this tree, used to determine when\n     * to rerender. */\n    @observable numOperations: number;\n    /** The function used to explain steps of tree operations. */\n    protected explainFunction: ExplainPromise;\n    /** A list of nodes in this tree that are highlighted. */\n    highlightedNodes: Array<BinaryTreeNode>;\n\n    /**\n     * Constructor for a binary search tree.  If items are specified, add them\n     * to the tree without explanation.\n     * \n     * @param items List of items to be added to this binary search tree.\n     */\n    constructor(explain: ExplainPromise, items: Array<number> = []) {\n        // Cannot call reset() or the TypeScript compiler throws a fit\n        this.root = new BinaryTreeNode(null);\n        this.size = 0;\n        this.numOperations = 0;\n        this.explainFunction = explain;\n        this.highlightedNodes = [];\n        items.forEach(item => this.addItem(item));\n    }\n\n    /**\n     * Reset this tree to its initial state, containing only a null root.\n     */\n    public reset(): void {\n        this.root = new BinaryTreeNode(null);\n        this.size = 0;\n        this.numOperations = 0;\n    }\n\n    /**\n     * Show an explanation for the current step of the ongoing operation using\n     * the passed explanation function.\n     *\n     * @param title The title of this step.\n     * @param message The body of the explanation for this step.\n     * @param terminal Whether this is the last step in the operation.\n     */\n    @action.bound\n    protected async explainStep(title: string, message: React.ReactElement, terminal: boolean = false): Promise<any> {\n        await this.explainFunction(title, message, terminal);\n        // Unhighlight all nodes from this step\n        this.highlightedNodes.forEach(node => {\n            node.renderProps.highlightColour = null;\n        });\n        this.highlightedNodes = [];\n    }\n\n    /**\n     * Explain the process of navigating through the tree from the specified\n     * node in search of the specified item.\n     *\n     * @param item The item for which the tree operation is being performed.\n     * @param node The tree node from which to navigate.\n     */\n    protected async explainNavigation(item: number, node: BinaryTreeNode): Promise<void> {\n        let directionName = item < node.value! ? 'left' : 'right';\n\n        await this.explainStep(`Navigate ${directionName} from ${node.value}`, <div>\n            We need to determine in which direction to navigate down the tree.\n            As the value under consideration, <strong>{item}</strong>, is less than the value of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>current node</HighlightNode>\n            , <strong>{node.value}</strong>, we shall navigate to the\n                <HighlightNode node={item < node.value! ? node.leftChild! : node.rightChild!} colour={HighlightColours.BLUE}>\n                    <strong>{directionName}</strong>\n                </HighlightNode>.\n        </div>);\n        return;\n    }\n\n    /**\n     * Add the specified item to this tree.  It is expected that the tree does\n     * not already contain this item.\n     *\n     * @param item The item to add to this tree.\n     */\n    public abstract async addItem(item: number): Promise<void>;\n\n    /**\n     * Remove the specified item from this tree.  It is expected that the tree\n     * contains this item.\n     *\n     * @param item The item to remove from this tree.\n     */\n    public abstract async removeItem(item: number): Promise<void>;\n\n    /**\n     * Add a node to this tree using the \"nave\" algorithm.\n     * @param newNode The node to be added to the tree.\n     * @param final Whether to designate the addition of the node as the final\n     *     operation of an explanation.\n     */\n    @action.bound\n    protected async addNodeNaive(newNode: BinaryTreeNode, final: boolean): Promise<void> {\n        this.root = await this.addRecursive(newNode, final, this.root);\n        this.root.parent = null;\n        this.size++;\n        this.numOperations++;\n    }\n\n    @action.bound\n    private async addRecursive(newNode: BinaryTreeNode, final: boolean, node: BinaryTreeNode): Promise<BinaryTreeNode> {\n        // We have reached a dead end, add here\n        if (node.value === null) {\n            await this.explainStep('Insert node', <div>\n                We have found a\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>position </HighlightNode>\n                at which we can insert our node. We shall do so, finishing our insertion operation.\n            </div>, final);\n            return newNode;\n        }\n\n        // Otherwise, determine which direction to travel: left if less than, right if greater\n        let newValue = newNode.value!;\n        await this.explainNavigation(newValue, node);\n        if (newValue < node.value) {\n            let leftChild = await this.addRecursive(newNode, final, node.leftChild!);\n            leftChild.parent = node;\n            node.leftChild = leftChild;\n        }\n        else if (newValue > node.value) {\n            let rightChild = await this.addRecursive(newNode, final, node.rightChild!);\n            rightChild.parent = node;\n            node.rightChild = rightChild;\n        }\n        return node;\n    }\n\n    /**\n     * Perform a pre-order traversal of this tree.\n     */\n    public async *traversePreOrder(): any {\n        if (this.root.value !== null)\n            yield* this.navigatePreOrder(this.root);\n\n        await this.explainStep('Traversal complete', <div>\n            The pre-order traversal of this tree is complete.\n            The full results may be seen in the list of tree contents in the sidebar.\n        </div>, true);\n    }\n\n    private async *navigatePreOrder(node: BinaryTreeNode): any {\n        let continuePreOrder = (node: BinaryTreeNode) => this.navigatePreOrder(node);\n        yield* this.explainTraverseCurrent(node);\n        yield* this.explainTraverseLeft(node, 'Next', continuePreOrder);\n        yield* this.explainTraverseRight(node, 'Finally', continuePreOrder);\n    }\n\n    /**\n     * Perform an in-order traversal of this tree.\n     */\n    public async *traverseInOrder(): any {\n        if (this.root.value !== null)\n            yield* this.navigateInOrder(this.root);\n\n        await this.explainStep('Traversal complete', <div>\n            The in-order traversal of this tree is complete.\n            The full results may be seen in the list of tree contents in the sidebar.\n        </div>, true);\n    }\n\n    private async *navigateInOrder(node: BinaryTreeNode): any {\n        let continueInOrder = (node: BinaryTreeNode) => this.navigateInOrder(node);\n        yield* this.explainTraverseLeft(node, 'First', continueInOrder);\n        yield* this.explainTraverseCurrent(node);\n        yield* this.explainTraverseRight(node, 'Finally', continueInOrder);\n    }\n\n    /**\n     * Perform a post-order traversal of this tree.\n     */\n    public async *traversePostOrder(): any {\n        if (this.root.value !== null)\n            yield* this.navigatePostOrder(this.root);\n\n        await this.explainStep('Traversal complete', <div>\n            The post-order traversal of this tree is complete.\n            The full results may be seen in the list of tree contents in the sidebar.\n        </div>, true);\n    }\n\n    private async *navigatePostOrder(node: BinaryTreeNode): any {\n        let continuePostOrder = (node: BinaryTreeNode) => this.navigatePostOrder(node);\n        yield* this.explainTraverseLeft(node, 'First', continuePostOrder);\n        yield* this.explainTraverseRight(node, 'Next', continuePostOrder);\n        yield* this.explainTraverseCurrent(node);\n    }\n\n    /**\n     * Explain the traversal of the current node.\n     * @param node The node for which to give an explanation.\n     * @param prefix The prefix to add to the explanation message.\n     */\n    private async *explainTraverseCurrent(node: BinaryTreeNode) {\n        yield node.value;\n        await this.explainStep('Add current node', <div>\n            Add the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>current node </HighlightNode>\n            to the list of results.\n        </div>);\n    }\n\n    /**\n     * Explain the traversal of the node to the left of the specified node.\n     * @param node The node from which to traverse.\n     * @param prefix The prefix to add to the explanation message.\n     * @param callback The function to use to continue traversing the tree.\n     */\n    private async *explainTraverseLeft(node: BinaryTreeNode, prefix: string, callback: (node: BinaryTreeNode) => any) {\n        if (node.leftChild!.value !== null) {\n            await this.explainStep('Traverse left child', <div>\n                {prefix}, proceed from the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>current node </HighlightNode>\n                down the subtree formed under its\n                    <HighlightNode node={node.leftChild!} colour={HighlightColours.BLUE}>left child</HighlightNode>.\n            </div>);\n            yield* callback(node.leftChild!);\n        }\n    }\n\n    /**\n     * Explain the traversal of the node to the right of the specified node.\n     * @param node The node from which to traverse.\n     * @param prefix The prefix to add to the explanation message.\n     * @param callback The function to use to continue traversing the tree.\n     */\n    private async *explainTraverseRight(node: BinaryTreeNode, prefix: string, callback: (node: BinaryTreeNode) => any) {\n        if (node.rightChild!.value !== null) {\n            await this.explainStep('Traverse right child', <div>\n                {prefix}, proceed from the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>current node </HighlightNode>\n                down the subtree formed under its\n                    <HighlightNode node={node.rightChild!} colour={HighlightColours.BLUE}>right child</HighlightNode>.\n            </div>);\n            yield* callback(node.rightChild!);\n        }\n    }\n}\n","import React from 'react';\nimport { action } from 'mobx';\n\nimport { AbstractTree, BinaryTreeNode } from './AbstractTree';\nimport HighlightNode, { HighlightColours } from '../components/HighlightNode/HighlightNode';\n\nexport default class NaiveTree extends AbstractTree {\n    @action.bound\n    public async addItem(item: number): Promise<void> {\n        await this.addNodeNaive(new BinaryTreeNode(item), true);\n    }\n\n    @action.bound\n    public async removeItem(item: number): Promise<void> {\n        this.root = await this.removeRecursive(item, this.root);\n        this.root.parent = null;\n        this.size--;\n        this.numOperations++;\n    }\n\n    @action.bound\n    private async removeRecursive(item: number, node: BinaryTreeNode): Promise<BinaryTreeNode> {\n        // If the node is a null leaf, it cannot be traversed down\n        if (node.value !== null) {\n            // Determine which direction to travel down the tree\n            if (item < node.value) {\n                await this.explainNavigation(item, node);\n                let leftChild = await this.removeRecursive(item, node.leftChild!);\n                leftChild.parent = node;\n                node.leftChild = leftChild;\n            } else if (item > node.value) {\n                await this.explainNavigation(item, node);\n                let rightChild = await this.removeRecursive(item, node.rightChild!);\n                rightChild.parent = node;\n                node.rightChild = rightChild;\n            } else {\n                // Remove the desired node from the subtree\n                if (node.isLeaf()) {\n                    await this.explainStep('Remove leaf node', <div>\n                        We have found the <HighlightNode node={node} colour={HighlightColours.RED}>node with value {item} </HighlightNode>\n                        , so we can now remove it.  This node is a leaf, with both its\n                            <HighlightNode node={node.leftChild!} colour={HighlightColours.GREEN}>left </HighlightNode>\n                        and\n                            <HighlightNode node={node.rightChild!} colour={HighlightColours.BLUE}>right </HighlightNode>\n                        children being <code>null</code>.\n                        We shall delete this node straightaway.\n                    </div>, true);\n\n                    // Node is a leaf: revert to null node\n                    let newNode = new BinaryTreeNode(null);\n                    newNode.parent = node;\n                    node = newNode;\n                } else if (node.leftChild!.value === null) {\n                    await this.explainStep('Promote right child', <div>\n                        We have found the <HighlightNode node={node} colour={HighlightColours.RED}>node with value {item} </HighlightNode>\n                        , so we can now remove it.  This node has only a \n                            <HighlightNode node={node.rightChild!} colour={HighlightColours.GREEN}>right </HighlightNode>\n                        child, with its\n                            <HighlightNode node={node.leftChild!} colour={HighlightColours.BLUE}>left </HighlightNode>\n                        child being <code>null</code>.\n                        As a result, we shall promote the <strong>right</strong> child to the removed node's position.\n                    </div>, true);\n\n                    // Left child is null, promote the right child\n                    node.rightChild!.parent = node.parent;\n                    node = node.rightChild!;\n                } else if (node.rightChild!.value === null) {\n                    await this.explainStep('Promote left child', <div>\n                        We have found the <HighlightNode node={node} colour={HighlightColours.RED}>node with value {item} </HighlightNode>\n                        , so we can now remove it.  This node has only a \n                            <HighlightNode node={node.leftChild!} colour={HighlightColours.GREEN}>left </HighlightNode>\n                        child, with its\n                            <HighlightNode node={node.rightChild!} colour={HighlightColours.BLUE}>right </HighlightNode>\n                        child being <code>null</code>.\n                        As a result, we shall promote the <strong>left</strong> child to the removed node's position.\n                    </div>, true);\n\n                    // Right child is null, promote the left child\n                    node.leftChild!.parent = node.parent;\n                    node = node.leftChild!;\n                } else {\n                    await this.explainStep('Find minimum greater value', <div>\n                        We have found the <HighlightNode node={node} colour={HighlightColours.RED}>node with value {item} </HighlightNode>\n                        , so we can now remove it.  This node has both\n                            <HighlightNode node={node.leftChild!} colour={HighlightColours.BLUE}>left </HighlightNode>\n                        and\n                            <HighlightNode node={node.rightChild!} colour={HighlightColours.GREEN}>right </HighlightNode>\n                        children, so we need to promote the minimum value in the <strong>right</strong> subtree.\n                    </div>);\n\n                    // Node has two children, promote the minimum value in the right subtree\n                    let minChild = node.rightChild!.minChild();\n\n                    await this.explainStep('Promote minimum greater value', <div>\n                        Now that we have found the\n                            <HighlightNode node={minChild} colour={HighlightColours.GREEN}>minimum greater node</HighlightNode>\n                        , we shall replace the\n                            <HighlightNode node={node} colour={HighlightColours.RED}>node to remove</HighlightNode>.\n                    </div>);\n                    node.value = minChild.value;\n\n                    await this.explainStep('Remove promoted node', <div>\n                        With the\n                            <HighlightNode node={node} colour={HighlightColours.GREEN}>promoted node </HighlightNode>\n                        having assumed its new position, we must now remove it from its\n                            <HighlightNode node={minChild} colour={HighlightColours.RED}>old position</HighlightNode>.\n                        We shall use the same algorithm we used to remove the initial node.\n                    </div>);\n                    let newRightChild = await this.removeRecursive(node.value!, node.rightChild!);\n                    newRightChild.parent = node;\n                    node.rightChild = newRightChild;\n                }\n            }\n        } else {\n            await this.explainStep('Null node', <div>\n                We have found a\n                    <HighlightNode node={node} colour={HighlightColours.RED}><code>null</code> node</HighlightNode>,\n                so we shall not operate upon it any further.\n            </div>, true);\n        }\n\n        return node;\n    }\n}\n","import React from 'react';\n\ninterface INodeColourProps {\n    colour: string;\n}\n\nexport default class NodeColour extends React.Component<INodeColourProps, {}> {\n    render(): React.ReactNode {\n        return <span style={{fontWeight: 600, color: this.props.colour}}>&#32;{this.props.colour}</span>\n    }\n}\n","import React from 'react';\nimport { action } from 'mobx';\n\nimport { AbstractTree, BinaryTreeNode } from './AbstractTree';\nimport HighlightNode, { HighlightColours } from '../components/HighlightNode/HighlightNode';\nimport NodeColour from '../components/HighlightNode/NodeColour';\n\nexport default class RedBlackTree extends AbstractTree {\n    private RED: string = 'red';\n    private BLACK: string = 'black';\n\n    @action.bound\n    public async addItem(item: number): Promise<void> {\n        let addedNode = new BinaryTreeNode(item, this.RED);\n        await this.addNodeNaive(addedNode, false);\n\n        await this.explainStep('Restore invariants', <div>\n            We have now added <strong>{item}</strong> to the tree as a\n                <HighlightNode node={addedNode} colour={HighlightColours.GREEN}>red node</HighlightNode>\n            ; however, it is possible that as a result of doing so, we have violated\n            one of the invariants of the red-black tree.  We shall now rebalance\n            the tree to ensure that all invariants hold.\n        </div>);\n\n        await this.rebalance(addedNode);\n    }\n\n    /**\n     * Rebalance this tree to restore all red-black tree invariants:\n     * - The root of the tree is black.\n     * - If a node is red, its children must be black (red rule).\n     * - Every path from a node to a null terminator must contain the same\n     *   number of black nodes (path rule).\n     *\n     * @param node The node relative to which to rebalance this tree.\n     */\n    @action.bound\n    private async rebalance(node: BinaryTreeNode): Promise<void> {\n        if (node === this.root) {\n            // If this node is the root, colour it black\n            node.colour = this.BLACK;\n            await this.explainStep('Colour root black', <div>\n                Since the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node to rebalance </HighlightNode>\n                is the root of the tree, we shall colour it <NodeColour colour={this.BLACK} />.\n            </div>, true);\n        } else if (node.parent!.colour === this.BLACK) {\n            // If the parent is black, no further modification is necessary\n            await this.explainStep('Invariants hold', <div>\n                Since the\n                    <HighlightNode node={node.parent!} colour={HighlightColours.BLUE}>parent </HighlightNode>\n                of this node is <NodeColour colour={this.BLACK} />, the addition of\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>\n                        this <NodeColour colour={this.RED} /> node\n                    </HighlightNode> does not violate the path rule.  No modification is necessary.\n            </div>, true);\n        } else if (node.ommer !== null && node.ommer.colour === this.RED) {\n            // If the parent and ommer are both red, recolour them black and colour the grandparent red\n            await this.explainStep('Recolour parent and uncle', <div>\n                We now have the case that the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node to rebalance</HighlightNode>, its\n                    <HighlightNode node={node.parent!} colour={HighlightColours.BLUE}>parent</HighlightNode>, and its\n                    <HighlightNode node={node.ommer} colour={HighlightColours.ORANGE}>uncle </HighlightNode>\n                are all <NodeColour colour={this.RED} />, a violation of the red rule.\n                To rectify this issue, we shall colour both the parent and the uncle <NodeColour colour={this.BLACK} />;\n                we shall also recolour the\n                    <HighlightNode node={node.grandparent!} colour={HighlightColours.RED}>grandparent </HighlightNode>\n                <NodeColour colour={this.RED} /> to maintain the path rule.\n            </div>);\n\n            node.ommer.colour = this.BLACK;\n            node.parent!.colour = this.BLACK;\n            node.grandparent!.colour = this.RED;\n\n            // Continue rebalancing up the tree\n            await this.explainStep('Restore invariants from grandparent', <div>\n                This recolouring has gotten us closer to a properly coloured tree;\n                however, it is possible that recolouring the\n                    <HighlightNode node={node.grandparent!} colour={HighlightColours.RED}>grandparent </HighlightNode>\n                <NodeColour colour={this.RED} /> has resulted in more invariant violations.\n                We shall continue rectifying the tree relative to the grandparent.\n            </div>);\n            await this.rebalance(node.grandparent!);\n        } else {\n            // The parent is red but the ommer is black: rotate!\n            await this.rebalanceDifferingAntecedents(node);\n        }\n\n        this.numOperations++;\n    }\n\n    @action.bound\n    private async rebalanceDifferingAntecedents(node: BinaryTreeNode): Promise<void> {\n        // At this point, we know that there is a grandparent, so let's save some !'s\n        let grandparent = node.grandparent!;\n        let parent = node.parent!;\n        await this.explainStep('Determine rotation direction', <div>\n            As the\n                <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent </HighlightNode>\n            of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>node to rebalance </HighlightNode>\n            is <NodeColour colour={this.RED} />, this tree currently violates the red rule.\n            To rectify this situation, we want to rotate the current node into the position of its\n                <HighlightNode node={grandparent} colour={HighlightColours.ORANGE}>grandparent</HighlightNode>.\n        </div>);\n\n        // Determine which direction to rotate, if any\n        let doRotateLeft = (node.isRightChild() && parent.isLeftChild());\n        let doRotateRight = (node.isLeftChild() && parent.isRightChild());\n        if (doRotateLeft || doRotateRight) {\n            // The current node is \"inside\" its grandparent, so we have to rotate\n            let rotateDirection = doRotateLeft ? 'left' : 'right';\n            await this.explainStep('Rotate outside grandparent', <div>\n                The <HighlightNode node={node} colour={HighlightColours.GREEN}>node to rebalance </HighlightNode>\n                is \"inside\" its\n                    <HighlightNode node={grandparent} colour={HighlightColours.ORANGE}>grandparent</HighlightNode>\n                : that is, it is not reachable by travelling solely {rotateDirection} from the grandparent.\n                To prepare to rotate relative to the grandparent, we must first rotate <strong>{rotateDirection}</strong> relative to the\n                    <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent</HighlightNode>.\n            </div>);\n        }\n\n        // If necessary, rotate outward\n        if (doRotateLeft) {\n            await this.rotateLeft(parent);\n            node = node.leftChild!;\n        } else if (doRotateRight) {\n            await this.rotateRight(parent);\n            node = node.rightChild!;\n        }\n\n        // Reassign parent and grandparent, as rotation could have changed them\n        parent = node.parent!;\n        grandparent = node.grandparent!;\n\n        // Rotate about the grandparent\n        await this.explainStep('Rotate about grandparent', <div>\n            We shall now shift our focus to the \n                <HighlightNode node={node} colour={HighlightColours.GREEN}>modified node </HighlightNode>\n            that is furthest down the tree.  We know that this node is \"outside\" its\n                <HighlightNode node={grandparent} colour={HighlightColours.ORANGE}>grandparent</HighlightNode>\n            : the path between these nodes through the modified node's\n                <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent </HighlightNode>\n            travels exclusively {node === parent.leftChild ? 'left': 'right'}.\n            If we now rotate <strong>{node === parent.leftChild ? 'right' : 'left'}</strong> about its grandparent,\n            which we know to be <NodeColour colour={this.BLACK} /> by way of the red rule,\n            then all that will be required to restore compliance with the red rule is a colour change.\n        </div>);\n\n        if (node.isLeftChild())\n            await this.rotateRight(grandparent);\n        else\n            await this.rotateLeft(grandparent);\n\n        // Recolour old parent and grandparent\n        await this.explainStep('Recolour relocated nodes', <div>\n            The final step in the rebalancing process is to recolour the\n            <HighlightNode node={node} colour={HighlightColours.GREEN}>modified node</HighlightNode>'s old\n            <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent</HighlightNode> and\n            <HighlightNode node={grandparent} colour={HighlightColours.ORANGE}>grandparent </HighlightNode>\n            (now sibling) to restore compliance with the red rule.\n            We shall colour the parent <NodeColour colour={this.BLACK} /> and the sibling <NodeColour colour={this.RED} />.\n        </div>, true);\n        parent.colour = this.BLACK;\n        grandparent.colour = this.RED;\n    }\n\n    /**\n     * Rotate the subtree formed by the specified node left:\n     * ```\n     *    A             C\n     *  B   C   =>   A    E\n     *     D E      B D\n     * ```\n     *\n     * @param node The node relative to which to rotate.\n     */\n    @action.bound\n    private async rotateLeft(node: BinaryTreeNode): Promise<void> {\n        let oldRight = node.rightChild!;\n        let oldParent = node.parent;\n        // Determine new right child of rotation node\n        await this.explainStep('Promote grandchild', <div>\n            We begin this rotation by promoting the\n                <HighlightNode node={oldRight.leftChild!} colour={HighlightColours.ORANGE}>left child </HighlightNode>\n            of the\n                <HighlightNode node={oldRight} colour={HighlightColours.BLUE}>right child </HighlightNode>\n            of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>rotated node </HighlightNode>\n            to be the rotated node's right child.\n        </div>);\n\n        node.rightChild = oldRight.leftChild;\n        oldRight.leftChild = node;\n        node.parent = oldRight;\n        if (node.rightChild!.value !== null)\n            node.rightChild!.parent = node;\n        // Force tree rerender\n        this.numOperations++;\n\n        await this.explainStep('Rotate under right child', <div>\n            Now that the\n                <HighlightNode node={node.rightChild!} colour={HighlightColours.ORANGE}>proper grandchild </HighlightNode>\n            of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>rotated node </HighlightNode>\n            has been promoted, we must place the rotated node under its old <strong>right child</strong> (not shown).\n        </div>);\n\n        // Only subjugate rotated node if it is not the root of the tree\n        if (oldParent !== null) {\n            if (node === oldParent.leftChild)\n                oldParent.leftChild = oldRight;\n            else\n                oldParent.rightChild = oldRight;\n        } else {\n            this.root = oldRight;\n        }\n        this.numOperations++;\n\n        // Set the new parent of the promoted node\n        oldRight.parent = oldParent;\n        await this.explainStep('Rotation complete', <div>\n            We have now finished the leftward rotation of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>target node </HighlightNode>\n            under its former\n                <HighlightNode node={oldRight} colour={HighlightColours.BLUE}>right child</HighlightNode>\n            , and can now proceed with our original operation.\n        </div>);\n    }\n\n    /**\n     * Rotate the subtree formed by the specified node right:\n     * ```\n     *     A            B\n     *   B   E   =>   C   A\n     *  C D              D E\n     * ```\n     *\n     * @param node The node relative to which to rotate.\n     */\n    @action.bound\n    private async rotateRight(node: BinaryTreeNode): Promise<void> {\n        let oldLeft = node.leftChild!;\n        let oldParent = node.parent;\n        // Determine new right child of rotation node\n        await this.explainStep('Promote grandchild', <div>\n            We begin this rotation by promoting the\n                <HighlightNode node={oldLeft.rightChild!} colour={HighlightColours.ORANGE}>right child </HighlightNode>\n            of the\n                <HighlightNode node={oldLeft} colour={HighlightColours.BLUE}>left child </HighlightNode>\n            of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>rotated node </HighlightNode>\n            to be the rotated node's left child.\n        </div>);\n\n        node.leftChild = oldLeft.rightChild;\n        oldLeft.rightChild = node;\n        node.parent = oldLeft;\n        if (node.leftChild!.value !== null)\n            node.leftChild!.parent = node;\n        // Force tree rerender\n        this.numOperations++;\n\n        await this.explainStep('Rotate under left child', <div>\n            Now that the\n                <HighlightNode node={node.leftChild!} colour={HighlightColours.ORANGE}>proper grandchild </HighlightNode>\n            of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>rotated node </HighlightNode>\n            has been promoted, we must place the rotated node under its old <strong>left child</strong> (not shown).\n        </div>);\n\n        // Only subjugate rotated node if it is not the root of the tree\n        if (oldParent !== null) {\n            if (node === oldParent.leftChild)\n                oldParent.leftChild = oldLeft;\n            else\n                oldParent.rightChild = oldLeft;\n        } else {\n            this.root = oldLeft;\n        }\n        this.numOperations++;\n\n        // Set the new parent of the promoted node\n        oldLeft.parent = oldParent;\n        await this.explainStep('Rotation complete', <div>\n            We have now finished the rightward rotation of the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>target node </HighlightNode>\n            under its former\n                <HighlightNode node={oldLeft} colour={HighlightColours.BLUE}>left child</HighlightNode>\n            , and can now proceed with our original operation.\n        </div>);\n    }\n\n    @action.bound\n    public async removeItem(item: number): Promise<void> {\n        let removedNode = await this.findRemovedNode(item, this.root);\n        // The value to remove should always be contained in the tree, but if it is not, return\n        if (removedNode === null) {\n            return;\n        }\n        await this.spliceNode(removedNode);\n        this.size--;\n        this.numOperations++;\n    }\n\n    /**\n     * Locate the node to be removed from this tree, explaining traversals along\n     * the way.\n     *\n     * @param item The value stored in the node to be removed from the tree.\n     * @param node The node relative to which to navigate down the tree.\n     * @returns The node containing the specified value; if there is no such\n     *     node, null.\n     */\n    @action.bound\n    private async findRemovedNode(item: number, node: BinaryTreeNode): Promise<BinaryTreeNode | null> {\n        if (node.value === null) {\n            // If the node is a null leaf, we cannot continue traversing\n            await this.explainStep('Null node', <div>\n                We have found a\n                    <HighlightNode node={node} colour={HighlightColours.RED}><code>null</code> node</HighlightNode>,\n                so we shall not operate upon it any further.\n            </div>, true);\n            return null;\n        }\n\n        // Navigate based on the value of the current node\n        if (item < node.value) {\n            await this.explainNavigation(item, node);\n            return await this.findRemovedNode(item, node.leftChild!);\n        } else if (item > node.value) {\n            await this.explainNavigation(item, node);\n            return await this.findRemovedNode(item, node.rightChild!);\n        } else {\n            return node;\n        }\n    }\n\n    /**\n     * Splice the specified node out of this tree according to red-black tree\n     * deletion rules:\n     * - If the node is a leaf, set it to null.\n     * - If the node has only one non-null child, set it to that child.\n     * - If the node has two non-null children, replace the node with the\n     *   minimum node in its right subtree.\n     *\n     * @param node The node to be removed from the tree.\n     */\n    @action.bound\n    private async spliceNode(node: BinaryTreeNode): Promise<void> {\n        // If the node has two children, promote the minimum greater value in the right subtree to avoid restructuring\n        if (node.leftChild!.value !== null && node.rightChild!.value !== null) {\n            await this.explainStep('Find minimum greater value', <div>\n                We have found the <HighlightNode node={node} colour={HighlightColours.RED}>node with value {node.value}</HighlightNode>\n                , which has both\n                    <HighlightNode node={node.leftChild!} colour={HighlightColours.BLUE}>left </HighlightNode>\n                and\n                    <HighlightNode node={node.rightChild!} colour={HighlightColours.GREEN}>right </HighlightNode>\n                children.  Instead of removing this node directly, we shall promote the minimum value in the <strong>right</strong> subtree\n                to avoid restructuring the tree.\n            </div>);\n            let minChild = node.rightChild!.minChild();\n\n            await this.explainStep('Promote minimum greater value', <div>\n                Now that we have found the\n                    <HighlightNode node={minChild} colour={HighlightColours.GREEN}>minimum greater node</HighlightNode>\n                , we shall promote its value into the\n                    <HighlightNode node={node} colour={HighlightColours.RED}>node to remove </HighlightNode>\n                and mark the <strong>minimum greater node</strong> for deletion instead.\n            </div>);\n            node.value = minChild.value;\n            node = minChild;\n        }\n\n        // This node is now known to have only one child\n        let definedChild = node.leftChild!.value === null ? node.rightChild! : node.leftChild!;\n        if (node === this.root) {\n            if (node.isLeaf()) {\n                // If the root is a leaf, it is safe to clear the tree\n                await this.removeLeaf(node, true);\n            } else {\n                await this.explainStep('Promote child to root', <div>\n                    We have found the\n                        <HighlightNode node={node} colour={HighlightColours.RED}>node with value {node.value}</HighlightNode>\n                    , so we can now remove it.  As this node is the root of the tree and it has only one\n                        <HighlightNode node={definedChild} colour={HighlightColours.GREEN}>non-null child</HighlightNode>\n                    , we can safely promote the child without violating any red-black tree invariants.\n                </div>, true);\n                // If we are removing the root, just replace the root with the non-null child\n                definedChild.parent = null;\n                this.root = definedChild;\n                // Root must be coloured black\n                definedChild.colour = this.BLACK;\n            }\n        } else if (node.colour === this.RED) {\n            // If we have made it this far and the node is red, it is a leaf\n            await this.removeLeaf(node, true);\n        } else if (definedChild.colour === this.RED) {\n            await this.explainStep('Promote child node', <div>\n                We have found the\n                    <HighlightNode node={node} colour={HighlightColours.RED}>node with value {node.value}</HighlightNode>\n                , so we can now remove it.  As this node has only\n                    <HighlightNode node={definedChild} colour={HighlightColours.GREEN}>one <NodeColour colour={this.RED} /> child</HighlightNode>\n                , we can promote that child to the position of the node to remove.\n            </div>);\n\n            // Removing a black node with a red child: promote the red child\n            if (node.isLeftChild()) {\n                node.parent!.leftChild = definedChild;\n            } else {\n                node.parent!.rightChild = definedChild;\n            }\n            definedChild.parent = node.parent;\n\n            await this.explainStep('Colour promoted node black', <div>\n                As a consequence of promoting a\n                    <HighlightNode node={definedChild} colour={HighlightColours.GREEN}><NodeColour colour={this.RED} /> node</HighlightNode>\n                , this tree now violates the path rule since paths through the promoted node will have one fewer <NodeColour colour={this.BLACK} /> node than others.\n                To rectify this issue, we shall colour the promoted node <NodeColour colour={this.BLACK} />.\n            </div>, true);\n\n            // Colour promoted node black to restore path rule compliance\n            definedChild.colour = this.BLACK;\n        } else {\n            let nodeDescription = node.isLeaf ? <span>a <NodeColour colour={this.BLACK} /> leaf</span>\n                : <span><NodeColour colour={this.BLACK} /> and has only\n                    <HighlightNode node={definedChild} colour={HighlightColours.GREEN}>one <NodeColour colour={this.BLACK} /> child</HighlightNode></span>;\n\n            await this.explainStep('Rebalance double-black path', <div>\n                We have found the\n                    <HighlightNode node={node} colour={HighlightColours.RED}>node with value {node.value}</HighlightNode>\n                , so we can now remove it.  As this node is {nodeDescription}, simply removing the node from the tree and promoting the child would result in a violation of the path rule.\n                Thus, we must first rebalance the tree to ensure that it will be compliant with the path rule after the target node has been deleted.\n            </div>);\n            // Removing a black node with a black child: multiple cases\n            await this.rebalanceRootDoubleBlack(node);\n\n            await this.explainStep('Remove desired node', <div>\n                Now that we have rebalanced the tree to ensure that no invariant violations will occur upon removing the\n                    <HighlightNode node={node} colour={HighlightColours.RED}>node with value {node.value} </HighlightNode>\n                by forcing it to become a leaf node, we can safely proceed to remove it from the tree.\n            </div>, true);\n            await this.removeLeaf(node, false);\n        }\n    }\n\n    /**\n     * \"Case One\" of double-black rebalancing.  If the node on which to\n     * rebalance is the root, colour it black.\n     *\n     * @param node The node relative to which to rebalance the tree.\n     */\n    @action.bound\n    private async rebalanceRootDoubleBlack(node: BinaryTreeNode): Promise<void> {\n        if (node.parent === null) {\n            await this.explainStep('Recolour root black', <div>\n                As the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n                the tree is also the root of the tree, we shall simply colour this node <NodeColour colour={this.BLACK} />.\n            </div>);\n            node.colour = this.BLACK;\n        } else {\n            // Case does not apply, proceed to next\n            await this.rebalanceRotateRedSibling(node);\n        }\n    }\n\n    /**\n     * \"Case Two\" of double-black rebalancing.  In the following case:\n     * - The parent of the node on which to rebalance is black\n     * - The sibling of this node is red\n     * - The sibling's children are black\n     *\n     * Rotate about the parent such that the sibling occupies its former\n     * position in the tree.\n     *\n     * @param node The node relative to which to rebalance the tree.\n     */\n    @action.bound\n    private async rebalanceRotateRedSibling(node: BinaryTreeNode): Promise<void> {\n        // Avoid non-null assertions\n        let parent = node.parent!, sibling = node.sibling!;\n        if (parent.colour === this.BLACK && sibling.colour === this.RED\n                && sibling.leftChild!.colour === this.BLACK && sibling.rightChild!.colour === this.BLACK) {\n            await this.explainStep('Rotate about parent', <div>\n                As the\n                    <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent </HighlightNode>\n                of the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n                the tree is <NodeColour colour={this.BLACK} /> and the\n                    <HighlightNode node={sibling} colour={HighlightColours.ORANGE}>rebalance node's sibling </HighlightNode>\n                is <NodeColour colour={this.RED} /> with\n                    <HighlightNode node={sibling.leftChild!} colour={HighlightColours.RED}>exclusively</HighlightNode> <NodeColour colour={this.BLACK} /> <HighlightNode node={sibling.rightChild!} colour={HighlightColours.RED}>children</HighlightNode>,\n                we can rotate <strong>{node.isLeftChild() ? 'left ' : 'right '}</strong> about the <strong>parent </strong>\n                to restore compliance with the path rule.\n            </div>);\n\n            // Rotate in order to promote the sibling\n            if (node.isLeftChild()) {\n                await this.rotateLeft(parent);\n            } else {\n                await this.rotateRight(parent);\n            }\n\n            await this.explainStep('Recolour rotated nodes', <div>\n                Now that we have finished rotating about the\n                    <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent </HighlightNode>\n                of the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance</HighlightNode>\n                , we still have a path rule violation to handle.\n                The <strong>{node.isLeftChild() ? 'right ' : 'left '}</strong> subtree of the\n                    <HighlightNode node={sibling} colour={HighlightColours.ORANGE}>promoted sibling </HighlightNode>\n                now has one fewer <NodeColour colour={this.BLACK} /> nodes than the\n                <strong>{node.isLeftChild() ? ' left ' : ' right '}</strong> subtree;\n                to rectify this issue, we can recolour the parent <NodeColour colour={this.RED} /> and the sibling <NodeColour colour={this.BLACK} />.\n            </div>);\n\n            // Recolour to restore path rule compliance\n            parent.colour = this.RED;\n            sibling.colour = this.BLACK;\n            await this.rebalanceRootDoubleBlack(node);\n        } else {\n            // Case does not apply, proceed to next\n            await this.rebalanceBlackCluster(node);\n        }\n    }\n\n    /**\n     * \"Case Three\" of double-black rebalancing.  In the following case:\n     * - The parent of the node on which to rebalance is black\n     * - The sibling of the node is black\n     * - The sibling's children are black\n     *\n     * Recolour the sibling red and rebalance relative to the parent.\n     *\n     * @param node The node relative to which to rebalanace the tree.\n     */\n    @action.bound\n    private async rebalanceBlackCluster(node: BinaryTreeNode): Promise<void> {\n        let parent = node.parent!, sibling = node.sibling!;\n        if (parent.colour === this.BLACK && sibling.colour === this.BLACK\n                && sibling.leftChild!.colour === this.BLACK && sibling.rightChild!.colour === this.BLACK) {\n            await this.explainStep('Recolour sibling red', <div>\n                As the\n                    <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent </HighlightNode>\n                of the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n                the tree is <NodeColour colour={this.BLACK} />, as are the\n                    <HighlightNode node={sibling} colour={HighlightColours.ORANGE}>rebalance node's sibling </HighlightNode>\n                and <HighlightNode node={sibling.leftChild!} colour={HighlightColours.RED}>both of</HighlightNode> <HighlightNode node={sibling.rightChild!} colour={HighlightColours.RED}>its children</HighlightNode>\n                , we shall recolour the sibling <NodeColour colour={this.RED} /> in an attempt to restore compliance with the path rule.\n                However, doing so may cause an invariant violation at a higher level of the tree,\n                so we shall now attempt to rebalance relative to the <strong>parent</strong>.\n            </div>);\n\n            // Recolour in a in attempt to restore path rule violation\n            sibling.colour = this.RED;\n            await this.rebalanceRootDoubleBlack(parent);\n        } else {\n            // Case does not apply, proceed to next\n            await this.rebalanceAlternatingSiblingBranch(node);\n        }\n    }\n\n    /**\n     * \"Case Four\" of double-black rebalancing.  In the following case:\n     * - The parent of the node on which to rebalance is red\n     * - The sibling of the node is black\n     * - The sibling's children are black\n     * \n     * Swap the colours of the parent and sibling to restore compliance with the\n     * path rule.\n     *\n     * @param node The node relative to which to rebalance the tree.\n     */\n    @action.bound\n    private async rebalanceAlternatingSiblingBranch(node: BinaryTreeNode): Promise<void> {\n        let parent = node.parent!, sibling = node.sibling!;\n        if (parent.colour === this.RED && sibling.colour === this.BLACK &&\n                sibling.leftChild!.colour === this.BLACK && sibling.rightChild!.colour === this.BLACK) {\n            await this.explainStep('Swap parent and sibling colours', <div>\n                As the\n                    <HighlightNode node={parent} colour={HighlightColours.BLUE}>parent </HighlightNode>\n                of the\n                    <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n                the tree is <NodeColour colour={this.RED} /> and the\n                    <HighlightNode node={sibling} colour={HighlightColours.ORANGE}>rebalance node's sibling </HighlightNode>\n                and <HighlightNode node={sibling.leftChild!} colour={HighlightColours.RED}>both of</HighlightNode> <HighlightNode node={sibling.rightChild!} colour={HighlightColours.RED}>its children </HighlightNode>\n                are <NodeColour colour={this.BLACK} />, we shall simply swap their colours to restore compliance with the path rule.\n            </div>);\n\n            // Swap colours without recursing\n            parent.colour = this.BLACK;\n            sibling.colour = this.RED;\n        } else {\n            // Case does not apply, proceed to next\n            await this.rebalanceRotateRedInnerNibling(node);\n        }\n    }\n\n    /**\n     * \"Case Five\" of double-black rebalancing.  In the following case:\n     * - The sibling of the node upon which to rebalance is black\n     * - The sibling's child to the inside of the tree is red\n     * - The sibling's child to the outside of the tree is black\n     *\n     * Rotate about the sibling in order to promote the inner child.  Also,\n     * recolour the sibling red and its inner child black.\n     *\n     * @param node The node relative to which to rebalance the tree.\n     */\n    @action.bound\n    private async rebalanceRotateRedInnerNibling(node: BinaryTreeNode): Promise<void> {\n        // Get the sibling's children to the inside and outside of the tree\n        let sibling = node.sibling!;\n        let [inner, outer] = node.isLeftChild() ? [sibling.leftChild!, sibling.rightChild!]\n            : [sibling.rightChild!, sibling.leftChild!];\n\n        if (sibling.colour === this.BLACK && inner.colour === this.RED && outer.colour === this.BLACK) {\n            await this.explainStep(\"Promote sibling's inner child\", <div>\n                As the\n                    <HighlightNode node={sibling} colour={HighlightColours.BLUE}>sibling </HighlightNode>\n                of the <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n                the tree is <NodeColour colour={this.BLACK} />, its\n                    <HighlightNode node={inner} colour={HighlightColours.RED}>child to the inside of the tree </HighlightNode>\n                is <NodeColour colour={this.RED} />, and its\n                    <HighlightNode node={outer} colour={HighlightColours.ORANGE}>outer child </HighlightNode>\n                is <NodeColour colour={this.BLACK} />, we shall rotate <strong>{node.isLeftChild() ? 'right ' : 'left '}</strong> about\n                the sibling in order to promote the inner child in anticipation of a path rule violation.\n            </div>);\n\n            // Rotate to promote the inner child\n            if (node.isLeftChild()) {\n                await this.rotateRight(sibling);\n            } else {\n                await this.rotateLeft(sibling);\n            }\n\n            await this.explainStep('Recolour rotated nodes', <div>\n                Having rotated in order to promote the\n                    <HighlightNode node={inner} colour={HighlightColours.RED}>inner child </HighlightNode>\n                of the <HighlightNode node={sibling} colour={HighlightColours.BLUE}>sibling </HighlightNode>\n                of the <HighlightNode node={node} colour={HighlightColours.GREEN}>rebalance node</HighlightNode>\n                , we are now ready to proceed to the final step of rebalancing for this node.\n                However, in order for this step to apply, we must recolour the sibling <NodeColour colour={this.RED} /> and\n                its former inner child (now parent) <NodeColour colour={this.BLACK} />.\n            </div>);\n\n            // Recolour in order to execute case 6\n            sibling.colour = this.RED;\n            inner.colour = this.BLACK;\n        }\n\n        // Proceed to the next case regardless\n        await this.rebalanceRotateRedOuterNibling(node);\n    }\n\n    /**\n     * \"Case Six\" of double-black rebalancing.  In the following case:\n     * - The sibling of the node upon which to rebalance is black\n     * - The sibling's child to the outside of the tree is red\n     *\n     * Rotate about the node's parent in order to promote the sibling's outer\n     * child.  Also, recolour the sibling the colour of its old parent and\n     * recolour both of its children (as evaluated after rotation) black.\n     *\n     * @param node The node relative to which to rebalance the tree.\n     */\n    @action.bound\n    private async rebalanceRotateRedOuterNibling(node: BinaryTreeNode): Promise<void> {\n        // Get the sibling's child to the outside of the tree\n        let parent = node.parent!, sibling = node.sibling!;\n        let outer = node.isLeftChild() ? sibling.rightChild! : sibling.leftChild!;\n\n        // No condition is necessary, as the cases are exhaustive\n        await this.explainStep(\"Promote sibling's outer child\", <div>\n            As the\n                <HighlightNode node={sibling} colour={HighlightColours.BLUE}>sibling </HighlightNode>\n            of the <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n            the tree is <NodeColour colour={this.BLACK} /> and its\n                <HighlightNode node={outer} colour={HighlightColours.ORANGE}>child to the outside of the tree </HighlightNode>\n            is <NodeColour colour={this.RED} />, we shall rotate <strong>{node.isLeftChild() ? 'left ' : 'right '}</strong> about\n            the rebalance node's\n                <HighlightNode node={parent} colour={HighlightColours.RED}>parent </HighlightNode>\n            in order to demote the rebalance node one level.\n        </div>);\n\n        // Rotate about the parent to promote the rebalance node\n        if (node.isLeftChild()) {\n            await this.rotateLeft(node.parent!);\n        } else {\n            await this.rotateRight(node.parent!);\n        }\n\n        await this.explainStep('Recolour rotated nodes', <div>\n            While we have now rotated the\n                <HighlightNode node={node} colour={HighlightColours.GREEN}>node upon which to rebalance </HighlightNode>\n            into the position of its former\n                <HighlightNode node={parent} colour={HighlightColours.RED}>parent</HighlightNode>\n            , we still have a path rule violation to handle in the subtree containing its former\n                <HighlightNode node={sibling} colour={HighlightColours.BLUE}>sibling</HighlightNode>\n            .  In order to rectify this issue, we shall colour the sibling's children <NodeColour colour={this.BLACK} /> and\n            assign the sibling the colour of its former parent, <NodeColour colour={parent.colour} />.\n        </div>);\n\n        sibling.colour = parent.colour;\n        sibling.leftChild!.colour = this.BLACK;\n        sibling.rightChild!.colour = this.BLACK;\n\n        // Rebalancing is now finished, so we can safely return to remove the desired node\n    }\n\n    /**\n     * Remove the specified node from the tree, provided that node is a leaf.\n     * Removal is done \"in-place\" by simply setting the value and children of\n     * the node to null.\n     *\n     * @param leaf The leaf node to remove from the tree.\n     * @param explain Whether to show an explanation for removal of the leaf as\n     *     a problem step.\n     */\n    @action.bound\n    private async removeLeaf(leaf: BinaryTreeNode, explain: boolean): Promise<void> {\n        if (explain) {\n            await this.explainStep('Replace leaf with null', <div>\n                We have found the\n                    <HighlightNode node={leaf} colour={HighlightColours.RED}>node with value {leaf.value}</HighlightNode>\n                , so we can now remove it.\n                Since this node is a leaf, we shall replace it with null as it has no children to promote.\n            </div>, true);\n        }\n\n        leaf.makeNull();\n    }\n}\n","import React from 'react';\nimport { inject } from 'mobx-react';\nimport { Button, Intent } from '@blueprintjs/core';\n\nimport ApplicationStore from '../../../stores/ApplicationStore';\nimport './TreeItem.css';\n\ninterface ITreeItemProps {\n    value: number;\n    index: number;\n    disabled: boolean;\n    applicationStore?: ApplicationStore;\n}\n\n@inject('applicationStore')\nexport default class TreeItem extends React.Component<ITreeItemProps, {}> {\n    /** Remove this node from all trees. */\n    private removeNode = () => {\n        this.props.applicationStore!.removeItemAtIndex(this.props.index);\n    };\n\n    render(): React.ReactNode {\n        return (\n            <div className=\"sidebarTreeItem\">\n                <div className=\"treeItemContents\">{this.props.value}</div>\n                <Button intent={Intent.DANGER} onClick={this.removeNode} disabled={this.props.disabled}>Remove</Button>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport { Button, ButtonGroup, Card, ControlGroup, Divider, Intent, NumericInput, Position, Slider, Switch, Tooltip } from '@blueprintjs/core';\nimport { IconNames } from '@blueprintjs/icons';\n\nimport ApplicationStore, { Traversal } from '../../stores/ApplicationStore';\nimport TreeItem from './TreeItem/TreeItem';\nimport './Sidebar.css';\n\ninterface ISidebarProps {\n    applicationStore?: ApplicationStore\n}\n\ninterface ISidebarState {\n    addOneValue: string;\n    addManyValue: string;\n}\n\n@inject('applicationStore')\n@observer\nexport default class Sidebar extends React.Component<ISidebarProps, ISidebarState> {\n    constructor(props: ISidebarProps) {\n        super(props);\n        this.state = { addOneValue: '', addManyValue: '' };\n    }\n\n    private addTreeItemKbd = (evt: React.KeyboardEvent<HTMLInputElement>) => {\n        // If the user pressed Enter, add their item to the tree\n        if (evt.key === 'Enter') {\n            this.addTreeItem();\n        }\n    }\n\n    private addTreeItem = () => {\n        if (this.state.addOneValue !== '') {\n            this.props.applicationStore!.addItem(+this.state.addOneValue);\n            this.setState({ addOneValue: '' });\n        }\n    };\n\n    private addManyAscending = async () => {\n        if (this.state.addManyValue !== '') {\n            for (let i = 1; i <= +this.state.addManyValue; i++)\n                await this.props.applicationStore!.addItem(i);\n\n            this.setState({ addManyValue: '' });\n        }\n    }\n\n    private addManyDescending = async () => {\n        if (this.state.addManyValue !== '') {\n            for (let i = +this.state.addManyValue; i >= 1; i++)\n                await this.props.applicationStore!.addItem(i);\n\n            this.setState({ addManyValue: '' });\n        }\n    }\n\n    private addManyRandom = async () => {\n        if (this.state.addManyValue !== '') {\n            // Generate a list of numbers in random order\n            let itemNum = +this.state.addManyValue;\n            let items = [];\n            for (let i = 1; i <= itemNum; i++)\n                items.push(i);\n            // Fisher-Yates shuffle\n            for (let i = itemNum - 1; i > 0; i--) {\n                const newIdx = Math.floor(Math.random() * (i + 1));\n                [items[i], items[newIdx]] = [items[newIdx], items[i]];\n            }\n            // Add values to tree\n            for (let i = 0; i < itemNum; i++)\n                await this.props.applicationStore!.addItem(items[i]);\n            this.setState({ addManyValue: '' });\n        }\n    }\n\n    private setAnimationInterval = (interval: number) => {\n        this.props.applicationStore!.animationInterval = interval;\n    }\n\n    render(): React.ReactNode {\n        let store = this.props.applicationStore!;\n        // Generate a list of the items in this tree\n        let treeOperating = store.treeOperating;\n        let treeItemList = store.items.map((item, idx) => {\n            return <TreeItem value={item} index={idx} key={item} disabled={treeOperating} />\n        });\n        let treeItems = <div className=\"sidebarTreeItems\">{treeItemList}</div>;\n\n        // If there are no items in the tree, show a placeholder instead\n        if (treeItemList.length === 0 && !treeOperating) {\n            treeItems = <Card>No items in tree &mdash; add one above!</Card>;\n        }\n\n        return (\n            <div className=\"sidebar\">\n                <ControlGroup fill>\n                    <NumericInput value={this.state.addOneValue}\n                        onValueChange={(asNum, asString) => this.setState({ addOneValue: asString })}\n                        leftIcon={IconNames.NEW_OBJECT}\n                        placeholder=\"Add an item\" onKeyUp={this.addTreeItemKbd}\n                        disabled={treeOperating} fill />\n                    <Button intent={Intent.SUCCESS} onClick={this.addTreeItem}\n                        disabled={treeOperating}>Add</Button>\n                </ControlGroup>\n\n                <ControlGroup className=\"addManyInput\" fill>\n                    <NumericInput value={this.state.addManyValue}\n                        onValueChange={(asNum, asString) => this.setState({ addManyValue: asString })}\n                        leftIcon={IconNames.ADD_TO_ARTIFACT} placeholder=\"Add many items\"\n                        disabled={treeOperating} fill />\n                    <Tooltip content=\"Add values ascending\" position={Position.BOTTOM}>\n                        <Button intent={Intent.SUCCESS} icon={IconNames.SORT_NUMERICAL}\n                            onClick={this.addManyAscending} disabled={treeOperating} />\n                    </Tooltip>\n                    <Tooltip content=\"Add values descending\" position={Position.BOTTOM}>\n                        <Button intent={Intent.SUCCESS} icon={IconNames.SORT_NUMERICAL_DESC}\n                            onClick={this.addManyDescending} disabled={treeOperating} />\n                    </Tooltip>\n                    <Tooltip content=\"Add values randomly\" position={Position.BOTTOM}>\n                        <Button intent={Intent.SUCCESS} icon={IconNames.SOCIAL_MEDIA}\n                            onClick={this.addManyRandom} disabled={treeOperating} />\n                    </Tooltip>\n                </ControlGroup>\n\n                <div>\n                    <Switch className=\"explainCheckbox\" checked={store.explainAdd}\n                        label=\"Explain additions\" onChange={store.toggleExplainAdd}\n                        disabled={treeOperating} inline />\n                    <Switch className=\"explainCheckbox\" checked={store.explainRemove}\n                        label=\"Explain removals\" onChange={store.toggleExplainRemove}\n                        disabled={treeOperating} inline />\n                    <Switch className=\"explainCheckbox\" checked={store.explainTraverse}\n                        label=\"Explain traversals\" onChange={store.toggleExplainTraverse}\n                        disabled={treeOperating} />\n\n                    <div className=\"animationSliderContainer\">\n                        Animation speed (ms):\n                        <Slider min={0} max={1000} stepSize={10} labelStepSize={250}\n                            value={store.animationInterval} onChange={this.setAnimationInterval} />\n                    </div>\n                </div>\n\n                <Divider />\n\n                <h2>Tree contents</h2>\n                <ButtonGroup className=\"sidebarTraversals\">\n                    <Button onClick={() => store.traverse(Traversal.PRE_ORDER)}\n                        disabled={treeOperating}>Pre-Order</Button>\n                    <Button onClick={() => store.traverse(Traversal.IN_ORDER)}\n                        disabled={treeOperating}>In-Order</Button>\n                    <Button onClick={() => store.traverse(Traversal.POST_ORDER)}\n                        disabled={treeOperating}>Post-Order</Button>\n                    <Button onClick={store.clearTree} intent={Intent.DANGER}\n                        disabled={treeOperating || store.tree.size === 0}>Clear</Button>\n                </ButtonGroup>\n                {treeItems}\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { observer } from 'mobx-react';\nimport { Icon } from '@blueprintjs/core';\nimport { IconNames } from '@blueprintjs/icons';\n\nimport { BinaryTreeNode } from \"../../../stores/AbstractTree\";\nimport './TreeNode.css';\n\ninterface ITreeNodeProps {\n    /** The node that this element represents. */\n    node: BinaryTreeNode;\n    /** The colour of this node as it is highlighted in the current explanation. */\n    highlight: string | null;\n}\n\ninterface ITreeNodeState {\n    color: string;\n    borderColor: string;\n    backgroundColor: string;\n}\n\n@observer\nexport default class TreeNode extends React.Component<ITreeNodeProps, ITreeNodeState> {\n    private ownRef: React.RefObject<any>;\n\n    constructor(props: ITreeNodeProps) {\n        super(props);\n        this.ownRef = React.createRef();\n\n        this.state = {\n            color: this.props.node.colour,\n            borderColor: this.props.node.colour,\n            backgroundColor: 'white'\n        };\n    }\n\n    /**\n     * Set the rendering properties of the underlying BinaryTreeNode for this\n     * node.  Used to trigger connection rendering.\n     */\n    private setRenderProps = () => {\n        // Set anchor coordinates to allow connections to be drawn\n        let bounds = this.ownRef.current.getBoundingClientRect();\n        let xCoordinate = this.ownRef.current.offsetLeft + bounds.width / 2;\n        this.props.node.renderProps.topAnchor = {\n            x: xCoordinate,\n            y: this.ownRef.current.offsetTop\n        };\n        this.props.node.renderProps.bottomAnchor = {\n            x: xCoordinate,\n            y: this.ownRef.current.offsetTop + bounds.height\n        };\n    };\n\n    static getDerivedStateFromProps(nextProps: any, prevState: ITreeNodeState) {\n        let nodeColour = nextProps.node.colour;\n        let highlightColour = nextProps.highlight;\n        let highlighted = highlightColour !== null;\n\n        if (nextProps.node.value === null) {\n            return {\n                color: highlighted ? highlightColour : '#aaa',\n                borderColor: highlighted ? highlightColour : '#ddd',\n                backgroundColor: highlighted ? `${highlightColour}11` : 'white'\n            };\n        } else {\n            return {\n                color: highlighted ? 'white' : nodeColour,\n                borderColor: nodeColour,\n                backgroundColor: highlighted ? highlightColour : 'white'\n            }\n        }\n    };\n\n    componentDidMount(): void {\n        this.setRenderProps();\n    }\n\n    componentDidUpdate(): void {\n        this.setRenderProps();\n    }\n\n    render(): React.ReactNode {\n        // If this node is non-null, navigate down the tree\n        if (this.props.node.value !== null) {\n            let { leftChild, rightChild } = this.props.node;\n            let leftNode = <TreeNode node={leftChild!} highlight={leftChild!.renderProps.highlightColour} />;\n            let rightNode = <TreeNode node={rightChild!} highlight={rightChild!.renderProps.highlightColour} />;\n\n            return (\n                <div className=\"subtreeGroup\">\n                    <div ref={this.ownRef} className=\"treeNode\" style={this.state}>\n                        {this.props.node.value}\n                    </div>\n                    <div className=\"treeNodeChildren\">\n                        {leftNode}\n                        {rightNode}\n                    </div>\n                </div>\n            );\n        }\n\n        // The node is null, render a placeholder\n        return (\n            <div ref={this.ownRef} className=\"treeNode nullNode\" style={this.state}>\n                <Icon icon={IconNames.DISABLE} />\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport { Button, ButtonGroup, Card, H4, Intent } from '@blueprintjs/core';\nimport { IconNames } from '@blueprintjs/icons';\n\nimport './ExplanationPane.css';\nimport ApplicationStore from '../../stores/ApplicationStore';\n\ninterface IExplanationPaneProps {\n    applicationStore?: ApplicationStore;\n}\n\n@inject('applicationStore')\n@observer\nexport default class ExplanationPane extends React.Component<IExplanationPaneProps, {}> {\n    /** Reference to the continue button, to allow focussing. */\n    private continueRef: React.RefObject<any>;\n\n    constructor(props: IExplanationPaneProps) {\n        super(props);\n        this.continueRef = React.createRef();\n    }\n\n    /** Advance to the next step of the explanation. */\n    nextStep = (continueAnimation: boolean) => {\n        let store = this.props.applicationStore!;\n        // If this was the last step, end the explanation\n        if (store.explanationTerminal) {\n            store.explaining = false;\n            store.explanationBody = null;\n        }\n\n        // Resolve the promise to continue\n        store.explaining = continueAnimation;\n        store.explanationPromise!.resolve();\n    };\n\n    componentDidUpdate() {\n        // Focus the continue button on every update\n        // if (this.continueRef.current !== null)\n        //     this.continueRef.current.focus();\n    }\n\n    render(): React.ReactNode {\n        let store = this.props.applicationStore!;\n        let actionButtons = (\n            <div className=\"actionButtons\">\n                <ButtonGroup>\n                    <Button rightIcon={IconNames.FAST_FORWARD} text=\"Finish\"\n                        onClick={() => this.nextStep(false)} />\n                    <Button rightIcon={IconNames.STEP_FORWARD} intent={Intent.PRIMARY} text=\"Next\"\n                        onClick={() => this.nextStep(true)} ref={this.continueRef} />\n                </ButtonGroup>\n            </div>\n        );\n        // Special action button for the last step\n        if (store.explanationTerminal) {\n            actionButtons = (\n                <div className=\"actionButtons\">\n                    <Button rightIcon={IconNames.TICK} intent={Intent.SUCCESS} text=\"Finished\"\n                        onClick={() => this.nextStep(false)} ref={this.continueRef} />\n                </div>\n            );\n        }\n\n        return (\n            <Card className=\"explanationCard\" style={{\n                display: store.explaining ? 'block' : 'none'\n            }}>\n                <H4>{store.explanationTitle}</H4>\n                {store.explanationBody}\n                {actionButtons}\n            </Card>\n        );\n    }\n}\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport './TreeDisplay.css';\nimport ApplicationStore from '../../stores/ApplicationStore';\nimport { BinaryTreeNode } from '../../stores/AbstractTree';\nimport TreeNode from './TreeNode/TreeNode';\nimport ExplanationPane from '../ExplanationPane/ExplanationPane';\n\ninterface ITreeDisplayProps {\n    applicationStore?: ApplicationStore;\n}\n\ninterface ITreeDisplayState {\n    connectionLines: Array<React.ReactNode>;\n}\n\n@inject('applicationStore')\n@observer\nexport default class TreeDisplay extends React.Component<ITreeDisplayProps, ITreeDisplayState> {\n    /** Whether connections have been rendered for the last update of this tree. */\n    private renderedConnections: boolean;\n\n    constructor(props: ITreeDisplayProps) {\n        super(props);\n        this.renderedConnections = false;\n        this.state = {\n            connectionLines: []\n        };\n    }\n\n    /** Render connections for all nodes in this tree. */\n    private renderConnections = () => {\n        if (!this.renderedConnections) {\n            // Render connection lines for this tree\n            let newConnectionLines: Array<React.ReactNode> = [];\n            this.renderNodeConnections(this.props.applicationStore!.tree.root, newConnectionLines, [0]);\n            // Avoid an infinite loop between componentDidUpdate() <-> render()\n            this.renderedConnections = true;\n            this.setState(() => ({\n                connectionLines: newConnectionLines\n            }));\n        } else {\n            // This was a recursive call: allow rendering on the next tree update\n            this.renderedConnections = false;\n        }\n    };\n\n    /** Render connections for the specified node and its descendants. */\n    private renderNodeConnections = (node: BinaryTreeNode, lines: Array<React.ReactNode>, key: [number]) => {\n        // Render connections to the left\n        if (node.leftChild !== null) {\n            lines.push(this.createConnection(node, node.leftChild, key[0]));\n            key[0]++;\n            this.renderNodeConnections(node.leftChild, lines, key);\n        }\n        // Render connections to the right\n        if (node.rightChild !== null) {\n            lines.push(this.createConnection(node, node.rightChild, key[0]));\n            key[0]++;\n            this.renderNodeConnections(node.rightChild, lines, key);\n        }\n    };\n\n    /** Create a tree connection between the specified nodes. */\n    private createConnection = (parent: BinaryTreeNode, child: BinaryTreeNode, key: number): React.ReactNode => {\n        let parentAnchor = parent.renderProps.bottomAnchor;\n        let childAnchor = child.renderProps.topAnchor;\n        // The left position should be that of whichever node is furthest left\n        let leftPos = Math.min(parentAnchor.x, childAnchor.x);\n        // Standard point-distance formula\n        let xDiff = childAnchor.x - parentAnchor.x;\n        let yDiff = childAnchor.y - parentAnchor.y;\n        let length = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2)) + 1;\n        // Compute the angle by which to rotate\n        let angle = Math.atan(yDiff / xDiff);\n\n        return (\n            <div className=\"treeDisplayConnection\" key={key} style={{\n                left: leftPos,\n                top: xDiff > 0 ? parentAnchor.y : childAnchor.y,\n                width: length,\n                transform: `rotate(${angle}rad)`\n            }}></div>\n        );\n    };\n\n    componentDidUpdate(): void {\n        this.renderConnections();\n    };\n\n    render(): React.ReactNode {\n        let treeRoot = this.props.applicationStore!.tree.root;\n\n        return (\n            <div className=\"treeDisplay\">\n                <div className=\"hiddenOps\">{this.props.applicationStore!.tree.numOperations}</div>\n                <TreeNode node={treeRoot} highlight={treeRoot.renderProps.highlightColour} />\n                {this.state.connectionLines}\n                <ExplanationPane />\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport { Alignment, Navbar, NavbarGroup, NavbarHeading, Tab, Tabs } from '@blueprintjs/core';\n\nimport ApplicationStore from '../stores/ApplicationStore';\nimport Sidebar from './Sidebar/Sidebar';\nimport TreeDisplay from './TreeDisplay/TreeDisplay';\n\ninterface IAppProps {\n    applicationStore?: ApplicationStore\n}\n\n@inject('applicationStore')\n@observer\nexport default class App extends React.Component<IAppProps, {}> {\n    render(): React.ReactNode {\n        return (\n            <div className=\"globalApp\">\n                <Navbar>\n                    <NavbarGroup align={Alignment.LEFT}>\n                        <NavbarHeading><strong>Tree Explorer</strong></NavbarHeading>\n                    </NavbarGroup>\n                    <NavbarGroup className=\"treeTypeTabs\" align={Alignment.LEFT}>\n                        <Tabs animate large onChange={this.props.applicationStore!.changeTreeType}>\n                            <Tab id=\"naiveTree\">Binary Search Tree</Tab>\n                            <Tab id=\"redBlackTree\">Red/Black Tree</Tab>\n                            <Tab id=\"avlTree\" disabled>AVL Tree</Tab>\n                        </Tabs>\n                    </NavbarGroup>\n                    <NavbarGroup align={Alignment.RIGHT}>\n                        <a className=\"ghLink\" href=\"https://github.com/Andrew-William-Smith/tree-explorer\" target=\"_blank\" rel=\"noopener noreferrer\">\n                            View on GitHub\n                        </a>\n                    </NavbarGroup>\n                </Navbar>\n                <div className=\"appBody\">\n                    <TreeDisplay />\n                    <Sidebar />\n                </div>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { Card, Collapse, Icon } from '@blueprintjs/core';\nimport { IconNames } from '@blueprintjs/icons';\n\nimport './CollapsiblePane.css';\n\ninterface ICollapsiblePaneProps {\n    children: React.ReactNode;\n    isOpen?: boolean;\n    titleActionsLeft?: React.ReactNode;\n    titleActionsRight?: React.ReactNode;\n    className?: string;\n}\n\ninterface ICollapsiblePaneState {\n    isOpen: boolean;\n}\n\nexport default class CollapsiblePane extends React.Component<ICollapsiblePaneProps, ICollapsiblePaneState> {\n    constructor(props: ICollapsiblePaneProps) {\n        super(props);\n        let isOpen = this.props.isOpen ?? true;\n        this.state = { isOpen };\n    }\n\n    private togglePaneOpen = () => {\n        this.setState({ isOpen: !this.state.isOpen });\n    };\n\n    render(): React.ReactNode {\n        // Satisfy the type-checker, which stumbles on ternaries\n        let collapseClass = this.state.isOpen ? '' : 'collapsiblePaneCollapsed';\n\n        return (\n            <Card className={this.props.className}>\n                <div className={`collapsiblePaneHeading ${collapseClass}`} onClick={this.togglePaneOpen}>\n                    <Icon icon={IconNames.CHEVRON_DOWN} />\n                    <span className=\"collapsiblePaneTitleActions\">\n                        <span className=\"collapsiblePaneTitleActionsLeft\">\n                            { this.props.titleActionsLeft }\n                        </span>\n                        <span className=\"collapsiblePaneTitleActionsRight\">\n                            { this.props.titleActionsRight }\n                        </span>\n                    </span>\n                </div>\n                <Collapse className=\"collapsiblePaneBody\" isOpen={this.state.isOpen}>\n                    { this.props.children }\n                </Collapse>\n            </Card>\n        );\n    }\n}\n","import React from 'react';\nimport { Callout, Divider, Intent, Pre } from '@blueprintjs/core';\nimport { IconNames } from '@blueprintjs/icons';\nimport '@blueprintjs/core/lib/css/blueprint.css';\n\nimport CollapsiblePane from '../CollapsiblePane/CollapsiblePane';\nimport './ErrorBoundary.css';\n\ninterface IErrorBoundaryProps {\n    children: React.ReactNode;\n}\n\ninterface IErrorBoundaryState {\n    error: Error | null;\n}\n\nexport default class ErrorBoundary extends React.Component<IErrorBoundaryProps, IErrorBoundaryState> {\n    state: IErrorBoundaryState = {\n        error: null\n    };\n\n    /**\n     * Set the ErrorBoundary's error state once one has occurred.\n     * @param error The error to associate with this ErrorBoundary.\n     */\n    static getDerivedStateFromError(error: Error): Partial<IErrorBoundaryState> {\n        return { error };\n    }\n\n    render(): React.ReactNode {\n        // An error has occurred, so render the error boundary\n        if (this.state.error) {\n            return (\n                <Callout className=\"errorCard\" title=\"He's dead, Jim!\" intent={Intent.DANGER} icon={IconNames.PULSE}>\n                    Tree Explorer has encountered a fatal error from which it is unable to recover.\n                    The tree you had entered should be considered to be lost.\n                    Refresh the page to continue exploring.\n\n                    <CollapsiblePane className=\"debugInfoPane\" titleActionsLeft=\"Debugging information\" isOpen={false}>\n                        <p><strong>Error type:</strong> {this.state.error.name}</p>\n                        <p><strong>Message:</strong> {this.state.error.message}</p>\n                        <Divider />\n                        <p><strong>Stack trace:</strong></p>\n                        <Pre>{this.state.error.stack}</Pre>\n                    </CollapsiblePane>\n                </Callout>\n            );\n        }\n\n        // No error has occurred, so render the normal contents\n        return this.props.children;\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'mobx-react';\n\nimport './index.css';\nimport App from './components/App';\nimport ErrorBoundary from './components/ErrorBoundary/ErrorBoundary';\n\n// Create a global instance of the application store\nimport ApplicationStore from './stores/ApplicationStore';\nconst APPLICATION_STORE = new ApplicationStore();\n\nReactDOM.render(\n    <Provider applicationStore={APPLICATION_STORE}>\n        <ErrorBoundary>\n            <App />\n        </ErrorBoundary>\n    </Provider>,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}